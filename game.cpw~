#include <iostream>
#include <cmath>
#include <cstdlib>
#include <list>
#include <SDL2/SDL.h>

#include "vector2d.h"
#include "enumeration.h"
#include "colourRGB.h"
#include "gameobject.h"
#include "sprite.h"

using namespace std;

static const int WINDOW_WIDTH=800;
static const int WINDOW_HEIGHT=600;

class GameCanvas{
public:
    static const int CANVAS_WIDTH=800;
    static const int CANVAS_HEIGHT=600;
    GameObject *player,ast;
    list<GameObject> object_list;
    Sprite *alien, *asteroid, *player_surf, *bullet;
    GameCanvas(){
        GameObject temp;
        load_resources();
        temp=GameObject(enum_player, player_surf, 2, Vector2d(400,300), false, Vector2d(0,0), 0,0, 60, true);
        temp.set_center(14,8);
        temp.make_hitbox(3);
        object_list.push_back(temp);
        player=&(object_list.front());

        temp=GameObject(enum_asteroid,asteroid,3,Vector2d(100,300),true,Vector2d(0,0),0,360,0,false);
        object_list.push_back(temp);
    }
/*    ~GameCanvas(){
        list<GameObject*>::iterator prev_it, it=object_list.begin();
        prev_it = it++;
        for(;it!=object_list.end();++it){
            delete *prev_it;
            prev_it=it;
        }
        
        delete alien;
        delete asteroid;
        delete player_surf;
        delete bullet;
    }*/
            
    void load_resources(){
        alien = new Sprite("./resources/alien.bmp", 2, 3, 1);
        asteroid = new Sprite("./resources/asteroid.bmp", 0,1,1);
        player_surf = new Sprite("./resources/spaceship.bmp", 2, 3, 1);
        bullet = new Sprite("./resources/bullet.bmp", 1,2,1);
    }
    void frame_loop(SDL_Renderer* r, SDL_Window* window){
        refire=0;
        respawn=1000;
        firing=false;
        unsigned int last_frame = SDL_GetTicks();
        unsigned int delta_spawn=0;
        unsigned int frame_t=17;
        while(1){
            unsigned int current_frame=SDL_GetTicks();
            unsigned int delta_t=current_frame - last_frame;
      //      cout<<"\t"<<object_list.size()<<endl;
            refire+=delta_t;
            delta_spawn+=delta_t;
            frame_t+=delta_t;
            if(firing and refire>fire_rate) fire_bullet();

            update_objects(delta_t);
            if(frame_t > 16){
                draw_objects(r,window);
                frame_t=0;
            }
            delete_objects();
            check_collisions();
            //delta_spawn=spawn_objects(delta_spawn);
            SDL_Event e;
            while(SDL_PollEvent(&e)){
                switch(e.type){
                    case(SDL_QUIT):
                        return;
                    case(SDL_KEYDOWN):
                        handle_key_down(e.key.keysym.sym);
                        break;
                    case(SDL_KEYUP):
                        handle_key_up(e.key.keysym.sym);
                        break;
                    default:
                        break;
                }
            }
            last_frame=current_frame;
        }
    }
    void draw_objects(SDL_Renderer *r, SDL_Window *w){
        SDL_RenderClear(r);
        GameObject obj;
        list<GameObject>::iterator it=object_list.begin();
        ++it; //skip past player. need to draw on top of bullets
        for(; it!=object_list.end(); ++it){
            obj=*it;
            obj.draw(r, w);
        }
        it=object_list.begin();
        (*it).draw(r, w);
        SDL_RenderPresent(r);
    }
    void update_objects(int delta_ms){
        GameObject obj;
        for(list<GameObject>::iterator it=object_list.begin(); it!=object_list.end(); ++it){
            (*it).update(delta_ms);
        }
    }
    //Delete the objects that have gone out of the screen
    void delete_objects(){
        GameObject obj;
        for(list<GameObject>::iterator it=object_list.begin(); it!=object_list.end(); ++it){
            obj=*it;
            if(obj.type!=enum_player and (obj.pos.x<-100 or obj.pos.y<-100 or obj.pos.x>CANVAS_WIDTH + 100 or obj.pos.y>CANVAS_HEIGHT + 100)){
               it=object_list.erase(it);
            }
        }
    }
    int spawn_objects(int dt){
        if(dt>respawn){
            GameObject obj;
            int rv=rand()%40;
            int sidex=rand()%2;
            int sidey=rand()%2;
            int x=abs(800*sidex - rand()%100);
            int y=abs(600*sidey - rand()%100);
            Vector2d pos(x,y);
            string file_name;
            double angle=rand()%360*M_PI/180;
            Vector2d v((double)rv*cos(angle), (double)rv*sin(angle));
            obj=GameObject(enum_asteroid,asteroid,rand()%3 + 1,pos,true,v,angle,rand()%81 - 40,0,false);
            object_list.push_back(obj);
            respawn=1000+rand()%4000; //Spawn every 1-5 seconds
            return 0;
        }    
        else return dt;
        return 0;   //Only to stop compiler from complaining
    }
    void check_collisions(){
        GameObject obj1,obj2;
        list<GameObject>::iterator it1,it2;
        for(it1=object_list.begin(); it1!=object_list.end(); ++it1){
            it2=it1;
            ++it2;
            for(;it2!=object_list.end(); ++it2){
                if((*it1).is_collided(*it2) and (*it1).type!=enum_player and (*it2).type!=enum_player){
                    cout<<"collision between "<<(*it1).type<<" and "<<(*it2).type<<endl;
                    obj1=*it1;
                    obj2=*it2;
                    object_list.erase(it2);
                    it1=object_list.erase(it1);
                    handle_collision(obj1,obj2);
                    break;
                }
            }
        }
    }
    void handle_collision(GameObject obj1, GameObject obj2){
        int new_scale, num_objects;
        Vector2d old_pos;
        if(obj1.type==enum_asteroid and obj2.type==enum_asteroid){
            if(obj1.scale < obj2.scale){
                new_scale = obj2.scale - 1;   
                old_pos = obj2.pos;
            }
            else{
                new_scale = obj1.scale - 1;
                old_pos = obj1.pos;
            }
            num_objects = obj2.scale + obj1.scale - 1;
        }        
        else if(obj1.type==enum_bullet or obj2.type==enum_bullet){ //At the moment it is impossible for two bullets to collide
            GameObject other;
            if(obj1.type==enum_bullet){
                other=obj2;
            }
            else{
                other=obj1;
            }
            new_scale = other.scale - 1;
            num_objects = new_scale + 1;
            old_pos = other.pos;
        }

        GameObject new_obj;
        Vector2d new_dir, new_pos;
        double angle_rad;
        int angle_deg;
        for(int i=0; i<num_objects; i++){
            angle_deg = (i*360/num_objects + rand()%45)%360;
            angle_rad = angle_deg*M_PI/180;
            new_dir = Vector2d(cos(angle_rad),sin(angle_rad));
            new_pos = new_scale*30*new_dir + old_pos;
            new_obj = GameObject(enum_asteroid,asteroid,new_scale,new_pos,false,(rand()%121 - 20)*new_dir,angle_deg,rand()%81 - 40,0,false);
            object_list.push_back(new_obj);
        }
    }
        
private:
    int respawn;
    bool firing;
    int refire;
    static const int fire_rate=100;    //ms/bullet
    void handle_key_down(SDL_Keycode key){
        if(key == SDLK_RIGHT){
            player->raccel=360;
        }
        else if(key == SDLK_LEFT){
            player->raccel=-360;
        }
        else if(key == SDLK_SPACE){
            firing=true; 
        }
        else if(key == SDLK_LSHIFT){
            player->animated=true;
            player->accel=60;
        }
    }
    void handle_key_up(SDL_Keycode key){
        if(key == SDLK_LEFT){
            player->raccel=0;
        }
        else if(key == SDLK_RIGHT){
            player->raccel=0;
        }
        else if(key == SDLK_SPACE){
            firing=false;
        }
        else if(key == SDLK_LSHIFT){
            player->accel=0;
            player->animated=false;
            player->set_frame(0);
        }
    }
    //Move to a ship class at some point
    void fire_bullet(){
        GameObject obj = GameObject(enum_bullet,bullet,2,player->pos + player->direction*14,
                false,350*player->direction,player->rotation,0,0,false);
        object_list.push_back(obj); 
        refire=0;
    }
};

int main(){
    SDL_Window* window=SDL_CreateWindow("Space Game",
                            SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
                            WINDOW_WIDTH, WINDOW_HEIGHT, SDL_WINDOW_SHOWN);
    SDL_Renderer* renderer=SDL_CreateRenderer(window,-1,0);

    SDL_SetRenderDrawColor(renderer,0,0,0,0);
    SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_NONE);
    SDL_RenderClear(renderer);
    SDL_RenderPresent(renderer);
    
    GameCanvas canvas;
    canvas.frame_loop(renderer, window);
    return 0;
}

#include <iostream>
#include <cmath>
#include <cstdlib>
#include <list>
#include <SDL2/SDL.h>

#include "vector2d.h"
#include "colourRGB.h"

using namespace std;

static const int WINDOW_WIDTH=800;
static const int WINDOW_HEIGHT=600;
enum ObjectType{
    enum_player,
    enum_enemy,
    enum_misc
};
class Sprite{
public:
    int max_frame;
    string file_name;

    Sprite(){
        height=0;
        width=0;
        max_frame=0;
        num_rows=0;
        num_cols=0;
        current_frame=0;
    }
    Sprite(string file_name, int max, int cols, int rows){
        load_file(file_name, max, cols, rows);
    }
    bool load_file(string file_name, int max, int cols, int rows){
        full_surf=SDL_LoadBMP(file_name.c_str());
        if(full_surf==NULL){
            cout<<"could not load file: "<<file_name<<"\t"<<SDL_GetError()<<endl;
            return false;
        }
        this->file_name=file_name;
        current_frame=0;
        max_frame=max;
        width=full_surf->w;
        height=full_surf->h;
        frame_rect.x=0;
        frame_rect.y=0;
        frame_rect.w=width/cols;
        frame_rect.h=height/rows;
        frame_surf=SDL_CreateRGBSurface(0,frame_rect.w,frame_rect.h,32,0,0,0,0);
        SDL_SetColorKey(full_surf, SDL_TRUE, SDL_MapRGB(full_surf->format,0,0xff,0xa1)); 
        SDL_SetColorKey(frame_surf, SDL_TRUE, SDL_MapRGB(frame_surf->format,0,0xff,0xa1)); 
        SDL_SetSurfaceBlendMode(full_surf, SDL_BLENDMODE_NONE);
        SDL_SetSurfaceBlendMode(frame_surf, SDL_BLENDMODE_NONE);
        num_cols=cols;
        num_rows=rows;
        return true;
    }
    void free(){
        if(full_surf==NULL){
            cout<<"no valid surface"<<endl;
            return;
        }
        SDL_FreeSurface(full_surf);
    }
    int get_width(){
        return width;
    }
    int get_height(){
        return height;
    }
    int get_frame_width(){
        return frame_width;
    }
    int get_frame_height(){
        return frame_height;
    }
    SDL_Surface* set_frame(int frame){
        if(frame > max_frame){
            cout<<"invalid frame"<<endl;
            return NULL;
        }
        frame_rect.x = frame%num_cols * frame_rect.w;
        frame_rect.y = frame/num_cols * frame_rect.h;
        SDL_BlitSurface(full_surf, &frame_rect, frame_surf, NULL);
        current_frame = frame;
        return frame_surf;
    }      
    SDL_Surface* operator [] (int i){
        cout<<"yo here we is\t"<<i<<endl;
        return set_frame(i);
    }
    int get_frame(){
        return this->current_frame;
    }
private:
    SDL_Rect frame_rect;
    SDL_Surface* full_surf, *frame_surf;
    int current_frame;
    int height, width;
    int frame_height, frame_width;
    int num_rows, num_cols;
};

class GameObject{
public:
    ObjectType type;
    Vector2d direction;
    Vector2d velocity; //Pixels/Second
    int accel, raccel;    //Pixels/Second/Second
    Vector2d pos;   //represents centre of sprite
    double rotation;
    double rspeed;     //Degrees/Second
    bool animated;

    GameObject(){
        type=enum_misc;
        scale=1;
    }
   GameObject(ObjectType type, Sprite* surf, int scale, Vector2d pos, bool animated, Vector2d v, int rotation, double rotv, int pframe, bool skip_first){
        accel=0;
        raccel=0;
        max_speed=360;
        frame_dt=0;
        current_frame=0;
        this->surf = surf;
        this->type=type;
        this->scale=scale;
        this->skip_first=skip_first;
        draw_rect.w=surf->get_frame_width() * scale;
        draw_rect.h=surf->get_frame_height() * scale;
        this->pos=pos;
        this->animated=animated;
        draw_rect.x=this->pos.x - draw_rect.w/2;
        draw_rect.y=this->pos.y - draw_rect.h/2;
        velocity=v;
        direction= v / v.length();
        this->rotation=rotation;
        this->rspeed=rotv;
        this->ms_per_frame=pframe;
        this->skip_first=skip_first;

        scale_surf=SDL_CreateRGBSurface(0,draw_rect.w,draw_rect.h,32,0,0,0,0);
        SDL_SetColorKey(scale_surf, SDL_TRUE, SDL_MapRGB(scale_surf->format,0,0xff,0xa1)); 
        SDL_SetSurfaceBlendMode(scale_surf, SDL_BLENDMODE_NONE);
    }
    void draw(SDL_Renderer* r, SDL_Window* window){
        SDL_BlitScaled((*surf)[current_frame],NULL,scale_surf,NULL); 

        SDL_Texture* sprite=SDL_CreateTextureFromSurface(r, scale_surf);
        SDL_RenderCopyEx(r, sprite, NULL, &draw_rect, rotation, NULL, SDL_FLIP_NONE);

        SDL_DestroyTexture(sprite);
        SDL_FillRect(scale_surf,NULL,SDL_MapRGB(scale_surf->format,0,0xff,0xa1)); 
    }
    void update(int delta_ms){
        double delta_s = delta_ms / 1000.0;
        frame_dt+=delta_ms;
        double dec;
        Vector2d dv;
        if(abs(rspeed)>max_speed){
            if(rspeed<0)    rspeed=-max_speed;
            else            rspeed=max_speed;
        }
        rspeed+=raccel * delta_s;
        rotation+=rspeed * delta_s;
        dec=rotation - (int)rotation;
        rotation=(int)rotation%360 + dec;
        direction.x = cos(rotation*M_PI/180);
        direction.y = sin(rotation*M_PI/180);

        velocity += accel*delta_s*direction;
        pos += velocity*delta_s;
        draw_rect.x = pos.x - draw_rect.w/2;
        draw_rect.y = pos.y - draw_rect.h/2;

        if(animated) animate();
    }
    void set_frame(int frame){
        current_frame=frame;
    }       
    int get_frame(){
        return current_frame;
    }
    void free_mem(){
        if(scale_surf!=NULL)
            SDL_FreeSurface(scale_surf);
    }
private:
    Sprite* surf;
    SDL_Surface *scale_surf;
    int current_frame;    
    int frame_dt;
    int ms_per_frame;
    int max_speed;
    SDL_Rect draw_rect;
    bool offset_pos, skip_first;
    int scale;

    void animate(){
        if(frame_dt<ms_per_frame) return;

        frame_dt=0;
        current_frame++;
        if(current_frame > surf->max_frame) current_frame = 0;
        if(skip_first and current_frame==0) current_frame=1;
    }
};
class GameCanvas{
public:
    static const int CANVAS_WIDTH=800;
    static const int CANVAS_HEIGHT=600;
    GameObject player;
    list<GameObject*> object_list;
    Sprite *alien, *asteroid, *player_surf, *bullet;
    GameCanvas(){
        load_resources();
        player=GameObject(enum_player, player_surf, 2, Vector2d(400,300), false, Vector2d(0,0), 0,0, 60, true);
        object_list.push_back(&player);
    }
    void load_resources(){
        alien = new Sprite("alien.bmp", 2, 3, 1);
        asteroid = new Sprite("asteroid.bmp", 0,1,1);
        player_surf = new Sprite("spaceship.bmp", 2, 3, 1);
        bullet = new Sprite("bullet.bmp", 0,1,1);
    }
    void frame_loop(SDL_Renderer* r, SDL_Window* window){
        refire=0;
        respawn=1000;
        firing=false;
        unsigned int last_frame = SDL_GetTicks();
        unsigned int delta_spawn=0;
        unsigned int frame_t=17;
        while(1){
            unsigned int current_frame=SDL_GetTicks();
            unsigned int delta_t=current_frame - last_frame;

            refire+=delta_t;
            delta_spawn+=delta_t;
            frame_t+=delta_t;
            if(firing and refire>fire_rate) fire_bullet();

            update_objects(delta_t);
            if(frame_t > 16){
                draw_objects(r,window);
                frame_t=0;
            }
            delete_objects();
            delta_spawn=spawn_objects(delta_spawn);
            SDL_Event e;
            while(SDL_PollEvent(&e)){
                switch(e.type){
                    case(SDL_QUIT):
                        return;
                    case(SDL_KEYDOWN):
                        handle_key_down(e.key.keysym.sym);
                        break;
                    case(SDL_KEYUP):
                        handle_key_up(e.key.keysym.sym);
                        break;
                    default:
                        break;
                }
            }
            last_frame=current_frame;
        }
    }
    void draw_objects(SDL_Renderer *r, SDL_Window *w){
        SDL_RenderClear(r);
        GameObject *obj;
        list<GameObject*>::iterator it=object_list.begin();
        ++it; //skip past player. need to draw on top of bullets
        for(; it!=object_list.end(); ++it){
            obj=*it;
            obj->draw(r, w);
        }
        it=object_list.begin();
        (*it)->draw(r, w);
        SDL_RenderPresent(r);
    }
    void update_objects(int delta_ms){
        GameObject* obj;
        for(list<GameObject*>::iterator it=object_list.begin(); it!=object_list.end(); ++it){
            obj=*it;
            obj->update(delta_ms);
        }
    }
    //Delete the objects that have gone out of the screen
    void delete_objects(){
        GameObject* obj;
        for(list<GameObject*>::iterator it=object_list.begin(); it!=object_list.end(); ++it){
            obj=*it;
            if(obj->type!=enum_player and (obj->pos.x<-100 or obj->pos.y<-100 or obj->pos.x>CANVAS_WIDTH + 100 or obj->pos.y>CANVAS_HEIGHT + 100)){
               it=object_list.erase(it);
               obj->free_mem();
               delete obj;
            }
        }
    }
    int spawn_objects(int dt){
        if(dt>respawn){
            GameObject* obj;
            int rv=rand()%40;
            int sidex=rand()%2;
            int sidey=rand()%2;
            int x=abs(800*sidex - rand()%100);
            int y=abs(600*sidey - rand()%100);
            Vector2d pos(x,y);
            string file_name;
            double angle=rand()%360*M_PI/180;
            Vector2d v((double)rv*cos(angle), (double)rv*sin(angle));
            if(rv%4==0)
                obj=new GameObject(enum_enemy,alien,2,pos,true,v,angle,rand()%81 - 40,120,false);
            else
                obj=new GameObject(enum_misc,asteroid,rand()%3 + 1,pos,false,v,angle,rand()%81 - 40,0,false);
            object_list.push_back(obj);
            respawn=1000+rand()%4000; //Spawn every 1-5 seconds
            return 0;
        }    
        else return dt;
        return 0;   //Only to stop compiler from complaining
    }
private:
    int respawn;
    bool firing;
    int refire;
    static const int fire_rate=100;    //ms/bullet
    void handle_key_down(SDL_Keycode key){
        if(key == SDLK_RIGHT){
            player.raccel=360;
        }
        else if(key == SDLK_LEFT){
            player.raccel=-360;
        }
        else if(key == SDLK_SPACE){
            firing=true; 
        }
        else if(key == SDLK_LSHIFT){
            player.animated=true;
            player.accel=60;
        }
    }
    void handle_key_up(SDL_Keycode key){
        if(key == SDLK_LEFT){
            player.raccel=0;
        }
        else if(key == SDLK_RIGHT){
            player.raccel=0;
        }
        else if(key == SDLK_SPACE){
            firing=false;
        }
        else if(key == SDLK_LSHIFT){
            player.accel=0;
            player.animated=false;
            player.set_frame(0);
        }
    }
    //Move to a ship class at some point
    void fire_bullet(){
        GameObject* obj = new GameObject(enum_misc,bullet,1,player.pos + player.direction*14,
                false,1000*player.direction,player.rotation,0,0,false);
        object_list.push_back(obj); 
        refire=0;
    }
};

int main(){
    SDL_Window* window=SDL_CreateWindow("Space Game",
                            SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
                            WINDOW_WIDTH, WINDOW_HEIGHT, SDL_WINDOW_SHOWN);
    SDL_Renderer* renderer=SDL_CreateRenderer(window,-1,0);

    SDL_SetRenderDrawColor(renderer,0,0,0,0);
    SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_NONE);
    SDL_RenderClear(renderer);
    SDL_RenderPresent(renderer);
    
    GameCanvas canvas;
    canvas.frame_loop(renderer, window);
    return 0;
}

#include <iostream>
#include <cmath>
#include <cstdlib>
#include <list>
#include <SDL2/SDL.h>

#include "vector2d.h"
#include "colourRGB.h"

using namespace std;

static const int WINDOW_WIDTH=800;
static const int WINDOW_HEIGHT=600;
enum ObjectType{
    enum_player,
    enum_enemy,
    enum_asteroid,
    enum_bullet,
    enum_misc
};
class HitBox{
public:
    int num_points;

    HitBox(SDL_Point* point, int num_points, SDL_Point draw_center){
        this->point = point;
        this->num_points = num_points;
        this->draw_center = draw_center;
    }
    HitBox(int rotation, int num_points, SDL_Point draw_center, int dist){
        this->new_rotation = rotation;
        this->num_points=num_points;
        this->dist = dist;
        if(num_points!=0) this->point = new SDL_Point[num_points];
        this->draw_center=draw_center;
        point = get_points()
    }
    SDL_Point* get_hitbox(){
        if(new_rotation!=current_rotation) do_rotation();        

        return point;
    }

    
private:
    SDL_Point *point, draw_center;
    int dist, current_rotation, new_rotation;

    SDL_Point *get_points(){
        int angle_deg;
        double angle_rad;
        point = NULL;
        if(num_points>2){
            point = new SDL_Point[num_points];
            if(num%2==0)
                angle_deg = 45;
            else
                angle_deg = 90;

            for(int i=0;i<num;i++){
                angle_rad = (double)angle_deg*M_PI/180.0;;
                point[i].x = cos(angle_rad)*dist + draw_center.x;
                point[i].y = sin(angle_rad)*dist + draw_center.y;
                angle_deg = (angle_deg + 360/num)%360;
            }
        }
    }
                    
                                    
            


    }
}   
class Sprite{
public:
    int max_frame;
    string file_name;

    Sprite(){
        height=0;
        width=0;
        max_frame=0;
        num_rows=0;
        num_cols=0;
        current_frame=0;
    }
    Sprite(string file_name, int max, int cols, int rows){
        load_file(file_name, max, cols, rows);
    }
    bool load_file(string file_name, int max, int cols, int rows){
        full_surf=SDL_LoadBMP(file_name.c_str());
        if(full_surf==NULL){
            cout<<"could not load file: "<<file_name<<"\t"<<SDL_GetError()<<endl;
            return false;
        }
        this->file_name=file_name;
        current_frame=-1;   //To allow the first blit onto the frame_surf
        max_frame=max;
        width=full_surf->w;
        height=full_surf->h;
        frame_rect.x=0;
        frame_rect.y=0;
        frame_rect.w=width/cols;
        frame_rect.h=height/rows;
        frame_width=frame_rect.w;
        frame_height=frame_rect.h;
        frame_surf=SDL_CreateRGBSurface(0,frame_rect.w,frame_rect.h,32,0,0,0,0);
        SDL_SetColorKey(full_surf, SDL_TRUE, SDL_MapRGB(full_surf->format,0,0xff,0xa1)); 
        SDL_SetColorKey(frame_surf, SDL_TRUE, SDL_MapRGB(frame_surf->format,0,0xff,0xa1)); 
        SDL_SetSurfaceBlendMode(full_surf, SDL_BLENDMODE_NONE);
        SDL_SetSurfaceBlendMode(frame_surf, SDL_BLENDMODE_NONE);
        num_cols=cols;
        num_rows=rows;
        return true;
    }
    void free(){
        if(full_surf==NULL){
            cout<<"no valid surface"<<endl;
            return;
        }
        SDL_FreeSurface(full_surf);
    }
    int get_width(){
        return width;
    }
    int get_height(){
        return height;
    }
    int get_frame_width(){
        return frame_width;
    }
    int get_frame_height(){
        return frame_height;
    }
    SDL_Surface* set_frame(int frame){
        if(frame == current_frame and frame_surf!=NULL) return frame_surf;

        SDL_FillRect(frame_surf,NULL,SDL_MapRGB(frame_surf->format,0,0xff,0xa1)); 
        if(frame > max_frame){
            cout<<"invalid frame"<<endl;
            return NULL;
        }
        frame_rect.x = frame%num_cols * frame_rect.w;
        frame_rect.y = frame/num_cols * frame_rect.h;
        //cout<<"frame rect: "<<frame_rect.x<<"\t"<<frame_rect.y<<endl;
        SDL_BlitSurface(full_surf, &frame_rect, frame_surf, NULL);
        current_frame = frame;
        return frame_surf;
    }      
    SDL_Surface* operator [] (int i){
        return set_frame(i);
    }
    int get_frame(){
        return this->current_frame;
    }
private:
    SDL_Rect frame_rect;
    SDL_Surface* full_surf, *frame_surf;
    int current_frame;
    int height, width;
    int frame_height, frame_width;
    int num_rows, num_cols;
};

class GameObject{
public:
    ObjectType type;
    Vector2d direction;
    Vector2d velocity; //Pixels/Second
    int accel, raccel;    //Pixels/Second/Second
    Vector2d pos, last_pos;   //represents centre of sprite, last_pos holds previous update's pos
    double rotation;
    string file_name;
    double rspeed;     //Degrees/Second
    bool animated;
    int scale;

    GameObject(){
        type=enum_misc;
        scale=1;
    }
    GameObject(ObjectType type, Sprite* sprite, int scale, Vector2d pos, bool animated, Vector2d v, int rotation, double rotv, int pframe, bool skip_first){
        accel=0;
        raccel=0;
        max_speed=360;
        frame_dt=0;
        current_frame=0;
        this->sprite = sprite;
        file_name=sprite->file_name;
        this->type=type;
        this->scale=scale;
        this->skip_first=skip_first;
        draw_rect.w=sprite->get_frame_width() * scale;
        draw_rect.h=sprite->get_frame_height() * scale;
        //cout<<"Sprite: "<<sprite->file_name<<"\twidth: "<<draw_rect.w<<"\theight: "<<draw_rect.h<<endl;
        this->pos=pos;
        last_pos=pos;
        this->animated=animated;
        draw_rect.x=this->pos.x - draw_rect.w/2;
        draw_rect.y=this->pos.y - draw_rect.h/2;
        velocity=v;
        direction= v / v.length();
        this->rotation=rotation;
        this->rspeed=rotv;
        this->ms_per_frame=pframe;
        this->skip_first=skip_first;
        center=NULL;

        scale_surf=SDL_CreateRGBSurface(0,draw_rect.w,draw_rect.h,32,0,0,0,0);
        SDL_SetColorKey(scale_surf, SDL_TRUE, SDL_MapRGB(scale_surf->format,0,0xff,0xa1)); 
        SDL_SetSurfaceBlendMode(scale_surf, SDL_BLENDMODE_NONE);
    }
    void draw(SDL_Renderer* r, SDL_Window* window){
        SDL_BlitScaled((*sprite)[current_frame],NULL,scale_surf,NULL); 

        SDL_Texture* sprite=SDL_CreateTextureFromSurface(r, scale_surf);
        SDL_RenderCopyEx(r, sprite, NULL, &draw_rect, rotation, center, SDL_FLIP_NONE);

        SDL_DestroyTexture(sprite);
        SDL_FillRect(scale_surf,NULL,SDL_MapRGB(scale_surf->format,0,0xff,0xa1)); 
    }
    void update(int delta_ms){
        double delta_s = delta_ms / 1000.0;
        frame_dt+=delta_ms;
        double dec;
        Vector2d dv;
        last_pos=pos;
        if(abs(rspeed)>max_speed){
            if(rspeed<0)    rspeed=-max_speed;
            else            rspeed=max_speed;
        }
        rspeed+=raccel * delta_s;
        rotation+=rspeed * delta_s;
        dec=rotation - (int)rotation;
        rotation=(int)rotation%360 + dec;
        direction.x = cos(rotation*M_PI/180);
        direction.y = sin(rotation*M_PI/180);

        velocity += accel*delta_s*direction;
        pos += velocity*delta_s;
        draw_rect.x = pos.x - draw_rect.w/2;
        draw_rect.y = pos.y - draw_rect.h/2;

        if(animated) animate();
    }
    void set_frame(int frame){
        current_frame=frame;
    }       
    int get_frame(){
        return current_frame;
    }
    void free_mem(){
        if(scale_surf!=NULL){
            SDL_FreeSurface(scale_surf);
            scale_surf = NULL;
        }
    }
    SDL_Rect get_hitbox(){
        return draw_rect;
    }
    bool is_collided(GameObject* other){
        /*Vector2d perp(direction.y,direction.x);
        Vector2d corner[4];
        SDL_Point point;
        SDL_Rect hit_box = other->get_hitbox();
        corner[0] = direction * draw_rect.h/2 - perp * draw_rect.w/2 + pos;
        corner[1] = corner[0] + draw_rect.w * perp;
        corner[2] = corner[0] + draw_rect.h * direction;
        corner[3] = corner[2] + draw_rect.w * perp;
        for(int i=0;i<4;i++){
            point.x=corner[i].x;
            point.y=corner[i].y;
            if(SDL_PointInRect(&point, &hit_box)) return true;
        } */ 
        int count=0;
        SDL_Rect hitbox = other->get_hitbox();
        SDL_Point point1 = { draw_rect.x, draw_rect.y};
        SDL_Point point2 = {draw_rect.x + draw_rect.w, draw_rect.y};
        count += SDL_PointInRect(&point1, &hitbox);
        count += SDL_PointInRect(&point2, &hitbox);
        point1.y += draw_rect.h;
        point2.y += draw_rect.h;
        count += SDL_PointInRect(&point1, &hitbox); 
        count += SDL_PointInRect(&point2, &hitbox);
        SDL_Point p1 = {(int)pos.x,(int)pos.y};
        SDL_Point p2 = {(int)last_pos.x,(int)last_pos.y};
        count += SDL_IntersectRectAndLine(&hitbox, &p1.x,&p1.y,&p2.x,&p2.y);

        return count > 0;
    }
    //This point is used only for rotations
    //pos is the real center of the sprite drawn on screen
    void set_center(int x, int y){
        if(center==NULL) center = new SDL_Point;
        center->x = x * scale;
        center->y = y * scale;
    }

private:
    Sprite* sprite;
    SDL_Surface *scale_surf;
    SDL_Point* center;
    int current_frame;    
    int frame_dt;
    int ms_per_frame;
    int max_speed;
    SDL_Rect draw_rect;
    bool offset_pos, skip_first;

    void animate(){
        if(frame_dt<ms_per_frame) return;

        frame_dt=0;
        current_frame++;
        if(current_frame > sprite->max_frame) current_frame = 0;
        if(skip_first and current_frame==0) current_frame=1;
    }
};
class GameCanvas{
public:
    static const int CANVAS_WIDTH=800;
    static const int CANVAS_HEIGHT=600;
    GameObject player;
    list<GameObject*> object_list;
    Sprite *alien, *asteroid, *player_surf, *bullet;
    GameCanvas(){
        load_resources();
        player=GameObject(enum_player, player_surf, 2, Vector2d(400,300), false, Vector2d(0,0), 0,0, 60, true);
        player.set_center(14,8);
        object_list.push_back(&player);
    }
    void load_resources(){
        alien = new Sprite("./resources/alien.bmp", 2, 3, 1);
        asteroid = new Sprite("./resources/asteroid.bmp", 0,1,1);
        player_surf = new Sprite("./resources/spaceship.bmp", 2, 3, 1);
        bullet = new Sprite("./resources/bullet.bmp", 1,2,1);
    }
    void frame_loop(SDL_Renderer* r, SDL_Window* window){
        refire=0;
        respawn=1000;
        firing=false;
        unsigned int last_frame = SDL_GetTicks();
        unsigned int delta_spawn=0;
        unsigned int frame_t=17;
        while(1){
            unsigned int current_frame=SDL_GetTicks();
            unsigned int delta_t=current_frame - last_frame;

            refire+=delta_t;
            delta_spawn+=delta_t;
            frame_t+=delta_t;
            if(firing and refire>fire_rate) fire_bullet();

            update_objects(delta_t);
            if(frame_t > 16){
                draw_objects(r,window);
                frame_t=0;
            }
            delete_objects();
            check_collisions();
            delta_spawn=spawn_objects(delta_spawn);
            SDL_Event e;
            while(SDL_PollEvent(&e)){
                switch(e.type){
                    case(SDL_QUIT):
                        return;
                    case(SDL_KEYDOWN):
                        handle_key_down(e.key.keysym.sym);
                        break;
                    case(SDL_KEYUP):
                        handle_key_up(e.key.keysym.sym);
                        break;
                    default:
                        break;
                }
            }
            last_frame=current_frame;
        }
    }
    void draw_objects(SDL_Renderer *r, SDL_Window *w){
        SDL_RenderClear(r);
        GameObject *obj;
        list<GameObject*>::iterator it=object_list.begin();
        ++it; //skip past player. need to draw on top of bullets
        for(; it!=object_list.end(); ++it){
            obj=*it;
            obj->draw(r, w);
        }
        it=object_list.begin();
        (*it)->draw(r, w);
        SDL_RenderPresent(r);
    }
    void update_objects(int delta_ms){
        GameObject* obj;
        for(list<GameObject*>::iterator it=object_list.begin(); it!=object_list.end(); ++it){
            obj=*it;
            obj->update(delta_ms);
        }
    }
    //Delete the objects that have gone out of the screen
    void delete_objects(){
        GameObject* obj;
        for(list<GameObject*>::iterator it=object_list.begin(); it!=object_list.end(); ++it){
            obj=*it;
            if(obj->type!=enum_player and (obj->pos.x<-100 or obj->pos.y<-100 or obj->pos.x>CANVAS_WIDTH + 100 or obj->pos.y>CANVAS_HEIGHT + 100)){
               it=object_list.erase(it);
               obj->free_mem();
               delete obj;
            }
        }
    }
    int spawn_objects(int dt){
        if(dt>respawn){
            GameObject* obj;
            int rv=rand()%40;
            int sidex=rand()%2;
            int sidey=rand()%2;
            int x=abs(800*sidex - rand()%100);
            int y=abs(600*sidey - rand()%100);
            Vector2d pos(x,y);
            string file_name;
            double angle=rand()%360*M_PI/180;
            Vector2d v((double)rv*cos(angle), (double)rv*sin(angle));
            obj=new GameObject(enum_asteroid,asteroid,rand()%3 + 1,pos,false,v,angle,rand()%81 - 40,0,false);
            object_list.push_back(obj);
            respawn=1000+rand()%4000; //Spawn every 1-5 seconds
            return 0;
        }    
        else return dt;
        return 0;   //Only to stop compiler from complaining
    }
    void check_collisions(){
        GameObject *obj1,*obj2;
        list<GameObject*>::iterator it;
        list<GameObject*>::reverse_iterator rit;
        for(it=object_list.begin(); it!=object_list.end(); ++it){
            for(rit=object_list.rbegin();*it!=*rit; ++rit){
                if((*it)->is_collided(*rit) and (*it)->type!=enum_player and (*rit)->type!=enum_player){
                    obj1=*it;
                    obj2=*rit;
                    object_list.remove(*rit);       //Converting rit to iterator is kinda a bitch so I just use remove
                    it=object_list.erase(it);
                    handle_collision(obj1,obj2);
                }
            }
        }
    }
    void handle_collision(GameObject* obj1, GameObject* obj2){
        int new_scale, num_objects;
        Vector2d old_pos;
        if(obj1->type==enum_asteroid and obj2->type==enum_asteroid){
            if(obj1->scale < obj2->scale){
                new_scale = obj2->scale - 1;   
                old_pos = obj2->pos;
            }
            else{
                new_scale = obj1->scale - 1;
                old_pos = obj1->pos;
            }
            num_objects = obj2->scale + obj1->scale - 1;
        }        
        else if(obj1->type==enum_bullet or obj2->type==enum_bullet){ //At the moment it is impossible for two bullets to collide
            GameObject* other;
            cout<<"boom?"<<endl;
            if(obj1->type==enum_bullet){
                other=obj2;
            }
            else{
                other=obj1;
            }
            new_scale = other->scale - 1;
            num_objects = new_scale + 1;
            old_pos = other->pos;
        }
        cout<<"Num new: "<<num_objects<<endl;

        GameObject* new_obj;
        Vector2d new_dir, new_pos;
        double angle_rad;
        int angle_deg;
        for(int i=0; i<num_objects; i++){
            angle_deg = (i*360/num_objects + rand()%45)%360;
            angle_rad = angle_deg*M_PI/180;
            new_dir = Vector2d(cos(angle_rad),sin(angle_rad));
            new_pos = new_scale*30*new_dir + old_pos;
            new_obj=new GameObject(enum_asteroid,asteroid,new_scale,new_pos,false,(rand()%121 - 20)*new_dir,angle_deg,rand()%81 - 40,0,false);
            object_list.push_back(new_obj);
        }
    }
        
private:
    int respawn;
    bool firing;
    int refire;
    static const int fire_rate=100;    //ms/bullet
    void handle_key_down(SDL_Keycode key){
        if(key == SDLK_RIGHT){
            player.raccel=360;
        }
        else if(key == SDLK_LEFT){
            player.raccel=-360;
        }
        else if(key == SDLK_SPACE){
            firing=true; 
        }
        else if(key == SDLK_LSHIFT){
            player.animated=true;
            player.accel=60;
        }
    }
    void handle_key_up(SDL_Keycode key){
        if(key == SDLK_LEFT){
            player.raccel=0;
        }
        else if(key == SDLK_RIGHT){
            player.raccel=0;
        }
        else if(key == SDLK_SPACE){
            firing=false;
        }
        else if(key == SDLK_LSHIFT){
            player.accel=0;
            player.animated=false;
            player.set_frame(0);
        }
    }
    //Move to a ship class at some point
    void fire_bullet(){
        GameObject* obj = new GameObject(enum_bullet,bullet,2,player.pos + player.direction*14,
                false,700*player.direction,player.rotation,0,0,false);
        object_list.push_back(obj); 
        refire=0;
    }
};

int main(){
    SDL_Window* window=SDL_CreateWindow("Space Game",
                            SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
                            WINDOW_WIDTH, WINDOW_HEIGHT, SDL_WINDOW_SHOWN);
    SDL_Renderer* renderer=SDL_CreateRenderer(window,-1,0);

    SDL_SetRenderDrawColor(renderer,0,0,0,0);
    SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_NONE);
    SDL_RenderClear(renderer);
    SDL_RenderPresent(renderer);
    
    GameCanvas canvas;
    canvas.frame_loop(renderer, window);
    return 0;
}
